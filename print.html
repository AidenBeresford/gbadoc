<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>gbadoc</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documents the workings of the Game Boy Advance hardware">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Intro</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="graphics.html"><strong aria-hidden="true">2.</strong> Graphics Hardware</a></li><li class="chapter-item expanded "><a href="audio/introduction.html"><strong aria-hidden="true">3.</strong> Audio</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="audio/directsound.html"><strong aria-hidden="true">3.1.</strong> Direct Sound</a></li><li class="chapter-item expanded "><a href="audio/sound1.html"><strong aria-hidden="true">3.2.</strong> Sound Channel 1</a></li><li class="chapter-item expanded "><a href="audio/sound2.html"><strong aria-hidden="true">3.3.</strong> Sound Channel 2</a></li><li class="chapter-item expanded "><a href="audio/sound3.html"><strong aria-hidden="true">3.4.</strong> Sound Channel 3</a></li><li class="chapter-item expanded "><a href="audio/sound4.html"><strong aria-hidden="true">3.5.</strong> Sound Channel 4</a></li><li class="chapter-item expanded "><a href="audio/registers.html"><strong aria-hidden="true">3.6.</strong> Sound Registers</a></li></ol></li><li class="chapter-item expanded "><a href="bootleg-carts/introduction.html"><strong aria-hidden="true">4.</strong> Bootleg Carts</a></li><li class="chapter-item expanded "><a href="ack.html"><strong aria-hidden="true">5.</strong> Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">gbadoc</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is a community effort to provide an open document about the Game Boy Advance (GBA).</p>
<p>The book is provided to you under the <a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">Creative Commons 0 License</a>.</p>
<p>If you'd like to ask questions, report problems, or contribute, then go to our <a href="https://github.com/gbdev/gbadoc">GitHub Repository</a>.</p>
<p>If you want to just chat about GBA topics you can join the <a href="https://discord.io/gbadev">GBADev Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<ul>
<li><strong>CPU:</strong> An <a href="https://en.wikipedia.org/wiki/ARM7#ARM7TDMI">ARM7TDMI</a> core running
at 16.78 MHz. No floating point unit.</li>
<li><strong>Screen:</strong> A 2.9 inch LCD screen with a 240 by 160 resolution.</li>
<li><strong>Video:</strong> Runs at approximately 59.72 Hz. Supports tiled graphics in &quot;text&quot; or
&quot;affine&quot; modes, as well as bitmap graphics. 5-bit per channel RGB color.</li>
<li><strong>Audio:</strong> Supports 8-bit wave output as well as the legacy Procedural Sound
Generator (PSG) chips from the Game Boy.</li>
<li><strong>Input:</strong> Directional pad (up, down, left, right, plus diagonals), four primary
buttons (A, B, L, R), two secondary buttons (Start, Select).</li>
<li><strong>Memory:</strong>
<ul>
<li>32k of CPU internal RAM (a small portion of this is pre-allocated)</li>
<li>256k of CPU external RAM (totally free for any use)</li>
<li>96k of Video RAM (the structure here depends on the video mode)</li>
<li>128 Object entries, used to display &quot;sprites&quot;.</li>
<li>32 Affine parameter entries.</li>
<li>256 palette entries for Backgrounds (&quot;backdrop&quot; plus 255 usable colors).</li>
<li>256 palette entries for Objects (of which 255 are usable).</li>
<li>Supports ROMs of up to 32MB in size.</li>
</ul>
</li>
<li><strong>Other Peripherals:</strong>
<ul>
<li>Serial port that supports up to four devices in the network.</li>
<li>Four Direct Memory Access (DMA) units. These perform faster memory copies
than the CPU can, and they can be set to automatically activate at
particular times, but the CPU is paused when they are active.</li>
<li>Four timer units.</li>
</ul>
</li>
</ul>
<p>Programs run on the GBA are usually contained in a &quot;Game Pak&quot;. A &quot;Game Pak&quot; consists mainly of ROM and possibly Cart RAM (in the form of SRAM, Flash ROM, or EEPROM, used mainly for save game info). The ROM is where compiled code and data is stored. Unlike home computers, workstations, or servers, there are no disks or other drives, so everything that might otherwise have been stored as separate resource files must be compiled into the program ROM itself. Luckily there are tools to aid in this process.</p>
<p>The primary means a program accesses specialized hardware for graphics, sound, and other IO is through the memory-mapped IO. Memory mapped IO is a means of communicating with hardware by writing to/reading from specific memory addresses that are &quot;mapped&quot; to internal hardware functions. For example, you might write to address 0x4000000 with the value &quot;0x0100&quot;, which tells the hardware &quot;enable background 0 and graphics mode 0&quot;. A secondary means is through the BIOS, which is embedded in the internal GBA system ROM. Using software interrupts it is possible to access pre-programmed (and hopefully optimized) routines lying in the the system ROM. These routines then access the hardware through the memory-mapped IO.</p>
<p>Other regions of memory that are directly mapped to the hardware are Palette RAM (which is a table consisting of all the available colors), VRAM (which performs a similar function to the video RAM on a PC - and thensome), and OAM (which contains the attributes for hardware accelerated sprites). </p>
<h2 id="memory-map"><a class="header" href="#memory-map">Memory Map</a></h2>
<p>The following are the general areas of memory as seen by the CPU, and what they are used for.</p>
<h3 id="system-rom-bios"><a class="header" href="#system-rom-bios">System ROM (BIOS)</a></h3>
<ul>
<li>Start: 0x00000000</li>
<li>End:  0x0003FFF</li>
<li>Size: 16kb </li>
<li>Port Size: 32 bit</li>
<li>Wait State: 0</li>
</ul>
<p>0x0 - 0x00003FFF contain the BIOS, which is executable but not readable. Any attempt to read in the area from 0x0 to 0x1FFFFFFF will result in failure; what you will see on a read is the current prefetched instruction (the instruction after the instruction used to view the memory area), thus giving the appearance that this area of memory consists of a repeating byte pattern.</p>
<h3 id="external-work-ram-ewram"><a class="header" href="#external-work-ram-ewram">External Work RAM (EWRAM)</a></h3>
<ul>
<li>Start: 0x02000000</li>
<li>End:   0x0203FFFF</li>
<li>Size:  256kb</li>
<li>Port Size: 16 bit</li>
<li>Mirrors:  Every 0x40000 bytes from 0x02000000 to 0x02FFFFFF</li>
</ul>
<p>This space is available for your game's data and code. If a multiboot cable is present on startup, the BIOS automatically detects it and downloads binary code from the cable and places it in this area, and execution begins with the instruction at address 0x02000000 (the default is 0x08000000). Though this is the largest area of RAM available on the GBA, memory transfers to and from EWRAM are 16 bits wide and thus consume more cycles than necessary for 32 bit accesses. Thus it is advised that 32 bit ARM code be placed in IWRAM rather than EWRAM.</p>
<h3 id="internal-work-ram-iwram"><a class="header" href="#internal-work-ram-iwram">Internal Work RAM (IWRAM)</a></h3>
<ul>
<li>Start: 0x03000000</li>
<li>End:   0x03007FFF</li>
<li>Size:  32kb</li>
<li>Port Size: 32 bit</li>
<li>Mirrors:  Every 0x8000 bytes from 0x03000000 to 0x03FFFFFF</li>
</ul>
<p>This space is also available for use. It is the fastest of all the GBA's RAM, being internally embedded in the ARM7 CPU chip package and having a 32 bit bus. As the bus for ROM and EWRAM is only 16 bits wide, the greatest efficiency will be gained by placing 32 bit ARM code in IWRAM while leaving thumb code for EWRAM or ROM memory.</p>
<h3 id="io-ram"><a class="header" href="#io-ram">IO Ram</a></h3>
<ul>
<li>Start: 0x04000000</li>
<li>End:   0x040003FF (0x04010000)</li>
<li>Size:  1Kb</li>
<li>Port Size:  Dual ported 32 bit</li>
<li>Mirrors:  The word at 0x04000800 (only!) is mirrored every 0x10000 bytes
from 0x04000000 - 0x04FFFFFF.</li>
</ul>
<p>This area contains a mirror of the ASIC (Application Specific Integrated Circuit) registers on the GBA. This area of memory is used to control the graphics, sound, DMA, and other features. See memory-mapped IO registers for details on the function of each register.</p>
<h3 id="palette-ram-palram"><a class="header" href="#palette-ram-palram">Palette RAM (PALRAM)</a></h3>
<ul>
<li>Start: 0x05000000</li>
<li>End:   0x050003FF</li>
<li>Size:  1kb</li>
<li>Port Size:  16 bit</li>
<li>Mirrors: Every 0x400 bytes from 0x05000000 to 0x5FFFFFF</li>
</ul>
<p>This area specifies the 16-bit color values for the paletted modes. There are two areas of the palette: one for backgrounds (0x05000000) and another for sprites (0x05000200). Each of these is either indexed as a single, 256-color palette, or as 16 individual 16-color palettes, depending on the settings of a particular sprite or background.</p>
<h3 id="video-ram-vram"><a class="header" href="#video-ram-vram">Video RAM (VRAM)</a></h3>
<ul>
<li>Start: 0x06000000</li>
<li>End:   0x06017FFF</li>
<li>Size:  96kb</li>
<li>Port Size: 16 bit</li>
<li>Mirrors: Bytes 0x06010000 - 0x06017FFF is mirrored from 0x06018000 - 0x0601FFFF.
The entire region from 0x06000000 - 0x06020000 is in turn mirrored every
0x20000 bytes from 0x06000000 - 0x06FFFFFF.</li>
</ul>
<p>The video RAM is used to store the frame buffer in bitmapped modes, and the tile data and tile maps for tile-based &quot;text&quot; and rotate/scale modes.</p>
<h3 id="obj-attribute-memory-oam"><a class="header" href="#obj-attribute-memory-oam">OBJ Attribute Memory (OAM)</a></h3>
<ul>
<li>Start: 0x07000000</li>
<li>End:   0x070003FF</li>
<li>Size:  1kb</li>
<li>Port Size: 32 bit</li>
<li>Mirrors: Every 0x400 bytes from 0x07000000 to 0x07FFFFFF</li>
</ul>
<p>This is the Object Attribute Memory, and is used to control the GBA's sprites.</p>
<p>The following areas of memory are technically cart-dependent, but can generally be expected to behave as described.</p>
<h3 id="game-pak-image-0-rom"><a class="header" href="#game-pak-image-0-rom">Game Pak, Image 0 (ROM)</a></h3>
<ul>
<li>Start: 0x08000000</li>
<li>Size:  The size of the cartridge (0 - 32 megabytes) </li>
<li>Port Size: 16 bit</li>
<li>Wait State: 0</li>
</ul>
<p>The ROM in the game cartridge appears in this area. If a cartridge is present on startup, the instruction found at location 0x08000000 is loaded into the program counter and execution begins from there. Note that the transfers to and from ROM are all 16 bits wide.</p>
<h3 id="game-pak-image-1-rom"><a class="header" href="#game-pak-image-1-rom">Game Pak, Image 1 (ROM)</a></h3>
<ul>
<li>Start: 0x0A000000</li>
<li>Size:  The size of the cartridge (0 - 32 megabytes)</li>
<li>Port Size:  16 bit</li>
<li>Wait State: 1</li>
</ul>
<p>This is a mirror of the ROM above. Used to allow multiple speed ROMs in a single game pak.</p>
<h3 id="game-pak-image-2-rom"><a class="header" href="#game-pak-image-2-rom">Game Pak, Image 2 (ROM)</a></h3>
<ul>
<li>Start: 0x0C000000</li>
<li>Size:  The size of the cartridge (0 - 32 megabytes)</li>
<li>Port Size: 16 bit</li>
<li>Wait State: 2</li>
</ul>
<p>This is a mirror of the ROM above. Used to allow multiple speed ROMs in a single game pak.</p>
<h3 id="game-pak-ram"><a class="header" href="#game-pak-ram">Game Pak RAM</a></h3>
<ul>
<li>Start: 0x0E000000 (also seem to appear at 0x0F000000)</li>
<li>Size:  0 - 64 kb</li>
<li>Port Size: 8 bit</li>
</ul>
<p>This is either SRAM or Flash ROM. Used primarily for saving game data. SRAM can be up to 64kb but is usually 32 kb. It has a battery backup so has the longest life (in terms of how many times it can be written to) of all backup methods. Flash ROM is usually 64 kb. Its lifespan is determined by the number of rewrites that can be done per sector (a 10,000 rewrite minimum is cited by some manufacturers).</p>
<h3 id="eeprom"><a class="header" href="#eeprom">EEPROM</a></h3>
<p>This is another kind of cart memory, but operates differently from SRAM or Flash ROM. Unfortunately, I don't know the details of how it can be accessed by the programmer (mail me if you have more information on it). It uses a serial connection to transmit data. The maximum size is 128 mb, but it can be any size, and is usually 4 kb or 64 kb. Like Flash ROM it has a limited life; some manufacturers cite a minimum of 100,000 rewrites per sector.</p>
<p>There may be other regions of memory known as DEBUG ROM 1 and DEBUG ROM 2, though I really don't know whether these are a part of commercial carts or if they are mapped to some part of the internal ROM, or if they're even available on a standard GBA.</p>
<p>Note that EWRAM, IWRAM, VRAM, OAM, Palette RAM are all initialized to zero by the BIOS (i.e. you can expect them to be zeroed at startup). </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphics-hardware-overview"><a class="header" href="#graphics-hardware-overview">Graphics Hardware Overview</a></h1>
<p>The GBA has a TFT color LCD that is 240 x 160 pixels in size and has a refresh rate of exactly 280,896 cpu cycles per frame, or around 59.73 hz. Most GBA programs will need to structure themselves around this refresh rate. Each refresh consists of a 160 scanline vertical draw (VDraw) period followed by a 68 scanline blank (VBlank) period. Furthermore, each of these scanlines consists of a 1004 cycle draw period (HDraw) followed by a 228 cycle blank period (HBlank). During the HDraw and VDraw periods the graphics hardware processes background and obj (sprite) data and draws it on the screen, while the HBlank and VBlank periods are left open so that program code can modify background and obj data without risk of creating graphical artifacts.
Video Modes</p>
<p>Exactly what the GBA draws on screen depends largely on the current video mode (also sometimes referred to as the screen mode or graphics mode). The GBA has 6 such modes, some of which are bitmap-based and some of which are tile-based. The video mode is set by the bottom three bits of the hardware register known as REG_DISPCNT. Background data is handled differently depending on what mode is enabled. Backgrounds can either be text backgrounds (tile based), rotate-scale backgrounds (tile based backgrounds that can be transformed), or bitmap backgrounds. The starting address and size sprite graphics memory is also dependent on video mode. It starts at 0x6010000 for tile modes and 0x6014000 for bitmapped modes.</p>
<p>Enabling objs and one or more backgrounds in REG_DISPCNT will cause the GBA to draw the specified backgrounds and objs in order of priority.</p>
<h3 id="mode-0"><a class="header" href="#mode-0">Mode 0</a></h3>
<p>In this mode, four text background layers can be shown. In this mode backgrounds 0 - 3 all count as &quot;text&quot; backgrounds, and cannot be scaled or rotated. Check out the section on text backgrounds for details on this.</p>
<h3 id="mode-1"><a class="header" href="#mode-1">Mode 1</a></h3>
<p>This mode is similar in most respects to Mode 0, the main difference being that only 3 backgrounds are accessible -- 0, 1, and 2. Bgs 0 and 1 are text backgrounds, while bg 2 is a rotation/scaling background.</p>
<h3 id="mode-2"><a class="header" href="#mode-2">Mode 2</a></h3>
<p>Like modes 0 and 1, this uses tiled backgrounds. It uses backgrounds 2 and 3, both of which are rotate/scale backgrounds.</p>
<h3 id="mode-3"><a class="header" href="#mode-3">Mode 3</a></h3>
<p>Standard 16-bit bitmapped (non-paletted) 240x160 mode. The map starts at 0x06000000 and is 0x12C00 bytes long. See the Color Format table above for the format of these bytes.</p>
<p>This allows the full color range to be displayed at once. Unfortunately, the frame buffer in this mode is too large for page flipping to be possible. One option to get around this would be to copy a frame buffer from work RAM into VRAM during the retrace, or (so I have heard) to use DMA3 with the start mode bits set to 11.</p>
<h3 id="mode-4"><a class="header" href="#mode-4">Mode 4</a></h3>
<p>8-Bit paletted bitmapped mode at 240x160. The bitmap starts at either 0x06000000 or 0x0600A000, depending on bit 4 of REG_DISPCNT. Swapping the map and drawing in the one that isn't displayed allows for page flipping techniques to be used. The palette is at 0x5000000, and contains 256 16-bit color entries.</p>
<h3 id="mode-5"><a class="header" href="#mode-5">Mode 5</a></h3>
<p>This is another 16-bit bitmapped mode, but at a smaller resolution of 160x128. The display starts at the upper left hand corner of the screen, but can be shifted using the rotation and scaling registers for BG2. The advantage of using this mode is presumably that there are two frame buffers available, and this can be used to perform page flipping effects which cannot be done in mode 3 due to the smaller memory requirements of mode 5. Bit 4 of REG_DISPCNT sets the start of the frame buffer to 0x06000000 when bit 4 is zero, and 0x600A000 when bit 4 is one. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>The Gameboy Advance (GBA) sound system may seem to many as black magic because of the availability of information on this specific part of the machine is near inexistent. Moreover, finding relevant or accurate specs for the older Gameboy was and is still problematic. The result is that many will take little or no advantages of sound in their projects. This site will attempt to fill this gap, by providing an <em>Unofficial</em>, comprehensive and (well, as much as possible in the circumstances) accurate specification of the GBA sound system (GBAS). It is assumed that the reader will have some knowledge of the other basic functionalities of the GBA and knows how to program in C.</p>
<p>The GBAS is a big step forward its older brothers because it now includes two Pulse Width Modulators (PWM) that act as digital-to-analog converters. This adds to the 4 sound channels present on the previous Gameboys. One important improvement to the sound system is that channel 3 's wave ram is now banked, allowing for distortion-free dynamic wave ram reloading.</p>
<p>The GBA BIOS also contains many sound-related functions, for converting MIDI notes and playing music. BIOS may be covered in the future.</p>
<h1 id="the-registers"><a class="header" href="#the-registers">The Registers</a></h1>
<p>Sound registers, as for all other registers in the GBA, are memory mapped and they span from 0x0400060 to 0x40000A6.</p>
<div class="table-wrapper"><table><thead><tr><th>Adress</th><th>Name</th><th>Function</th></tr></thead><tbody>
<tr><td>0x04000060</td><td>REG_SOUND1CNT_L</td><td>Sound 1 Sweep control</td></tr>
<tr><td>0x04000062</td><td>REG_SOUND1CNT_H</td><td>Sound 1 Length, wave duty and envelope control</td></tr>
<tr><td>0x04000064</td><td>REG_SOUND1CNT_X</td><td>Sound 1 Frequency, reset and loop control</td></tr>
<tr><td>0x04000068</td><td>REG_SOUND2CNT_L</td><td>Sound 2 Lenght, wave duty and envelope control</td></tr>
<tr><td>0x0400006C</td><td>REG_SOUND2CNT_H</td><td>Sound 2 Frequency, reset and loop control</td></tr>
<tr><td>0x04000070</td><td>REG_SOUND3CNT_L</td><td>Sound 3 Enable and wave ram bank control</td></tr>
<tr><td>0x04000072</td><td>REG_SOUND3CNT_H</td><td>Sound 3 Sound lenght and output level control</td></tr>
<tr><td>0x04000074</td><td>REG_SOUND3CNT_X</td><td>Sound 3 Frequency, reset and loop control</td></tr>
<tr><td>0x04000078</td><td>REG_SOUND4CNT_L</td><td>Sound 4 Length, output level and envelope control</td></tr>
<tr><td>0x0400007C</td><td>REG_SOUND4CNT_H</td><td>Sound 4 Noise parameters, reset and loop control</td></tr>
<tr><td>0x04000080</td><td>REG_SOUNDCNT_L</td><td>Sound 1-4 Output level and Stereo control</td></tr>
<tr><td>0x04000082</td><td>REG_SOUNDCNT_H</td><td>Direct Sound control and Sound 1-4 output ratio</td></tr>
<tr><td>0x04000084</td><td>REG_SOUNDCNT_X</td><td>Master sound enable and Sound 1-4 play status</td></tr>
<tr><td>0x04000088</td><td>REG_SOUNDBIAS</td><td>Sound bias and Amplitude resolution control</td></tr>
<tr><td>0x04000090</td><td>REG_WAVE_RAM0_L</td><td>Sound 3 samples 0-3</td></tr>
<tr><td>0x04000092</td><td>REG_WAVE_RAM0_H</td><td>Sound 3 samples 4-7</td></tr>
<tr><td>0x04000094</td><td>REG_WAVE_RAM1_L</td><td>Sound 3 samples 8-11</td></tr>
<tr><td>0x04000096</td><td>REG_WAVE_RAM1_H</td><td>Sound 3 samples 12-15</td></tr>
<tr><td>0x04000098</td><td>REG_WAVE_RAM2_L</td><td>Sound 3 samples 16-19</td></tr>
<tr><td>0x0400009A</td><td>REG_WAVE_RAM2_H</td><td>Sound 3 samples 20-23</td></tr>
<tr><td>0x0400009C</td><td>REG_WAVE_RAM3_L</td><td>Sound 3 samples 23-27</td></tr>
<tr><td>0x0400009E</td><td>REG_WAVE_RAM3_H</td><td>Sound 3 samples 28-31</td></tr>
<tr><td>0x040000A0</td><td>REG_FIFO_A_L</td><td>Direct Sound channel A samples 0-1</td></tr>
<tr><td>0x040000A2</td><td>REG_FIFO_A_H</td><td>Direct Sound channel A samples 2-3</td></tr>
<tr><td>0x040000A4</td><td>REG_FIFO_B_L</td><td>Direct Sound channel B samples 0-1</td></tr>
<tr><td>0x040000A6</td><td>REG_FIFO_B_H</td><td>Direct Sound channel B samples 2-3</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="direct-sound"><a class="header" href="#direct-sound">Direct Sound</a></h1>
<p>Direct Sound (not to confuse with DirectSound which is a registered trademark of Microsoft) refers to the two 8-bit digitial-to-analog converters part of the Gameboy Advance sound system (GBAS). The samples to be played, which must be 8-bit signed, are loaded in consecutive adresses starting at 0x40000A0 (REG_FIFO_A). These adresses acts as a FIFO (First-In-First-Out), meaning that lower adresses bytes are played first. Playback frequency is controlled by the overflow of either Timer 0 or Timer 1, allowing the two Direct sound channels to play at different frequencies independently. Direct sound can work in two modes: DMA mode and Interrupt mode. DMA mode is the most efficient way of playing Direct sound. Because once empty, sound FIFOs are automatically reloaded with the next samples by the DMA controller, without any program intervention. The other mode uses an interrupt handler that manually load the FIFOs. This is less efficient than DMA mode but in some cases, it is the only solution.</p>
<h2 id="direct-sound-output-control-register"><a class="header" href="#direct-sound-output-control-register">Direct Sound Output Control Register</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x082</td><td>REG_SOUNDCNT_H</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>1-0</td><td>Output sound ratio for chan. 1-4 (0=25%,1=50%,2=100%)</td><td>RW</td></tr>
<tr><td>2</td><td>Direct sound A output ratio (0=50%, 1=100%)</td><td>RW</td></tr>
<tr><td>3</td><td>Direct sound B output ratio (0=50%, 1=100%)</td><td>RW</td></tr>
<tr><td>7-4</td><td>Unused</td><td></td></tr>
<tr><td>8</td><td>Direct sound A to right output</td><td>RW</td></tr>
<tr><td>9</td><td>Direct sound A to left output</td><td>RW</td></tr>
<tr><td>A</td><td>Direct sound A Sampling rate timer (timer 0 or 1)</td><td>RW</td></tr>
<tr><td>B</td><td>Direct sound A FIFO reset</td><td>RW</td></tr>
<tr><td>C</td><td>Direct sound B to right output</td><td>RW</td></tr>
<tr><td>D</td><td>Direct sound B to left output</td><td>RW</td></tr>
<tr><td>E</td><td>Direct sound B Sampling rate timer (timer 0 or 1)</td><td>RW</td></tr>
<tr><td>F</td><td>Direct sound B FIFO reset</td><td>RW</td></tr>
</tbody></table>
</div>
<p>Output ratios control the output volume. Set these bits when Sound 1-4 or Direct Sound plays too loud relative to each other. Direct Sound channels can be send to Left, Rigth or both outputs. Bit A and E selects which timer to use as the sampling frequncy reference. Both Direct sound channels can use the same timer, and it is usually the case for software mixing. FIFO reset prepares the Direct sound harware for playback and put the playing cursor back to FIFO's sample 0. It should always be performed before playback start.</p>
<p>The following examples demonstrate Direct Sound playback in DMA mode and Interrupt mode.</p>
<h2 id="dma-mode-direct-sound-example"><a class="header" href="#dma-mode-direct-sound-example">DMA Mode Direct Sound Example</a></h2>
<p>To use DirectSound in DMA mode:</p>
<ul>
<li>Set DS outputs and volumes</li>
<li>Set timer0 (or 1) count value to 0xffff-round(cpuFreq/playbackFreq)
<ul>
<li>ie: For 16khz, timer count=65536-round(2^24/16000)=0xFBE8</li>
</ul>
</li>
<li>Set DMA channel's source to the sample's address and destination adress to either FIFOA or FIFOB adresses</li>
<li>Reset the FIFO before starting sound by setting the FIFO reset bit.</li>
<li>Set DMA start mode to 11 to instruct DMA to repeat on FIFO-empty requests. Many documents list this state as invalid, which is naturally not the case.
<ul>
<li>ie:REG_DMA1CNT_H=0xb600=DMA enabled+ start on FIFO+32bit+repeat</li>
</ul>
</li>
<li>Set DMA repeat and 32bit moves and set source and destination modes to increment.</li>
<li>Enable timer0 at Cpu frequency (clock divider=0)</li>
</ul>
<p>Sound should start immediately and will play past the sample if not stopped. You can use timer1 to count played samples and stop the sound. To do this, set timer 1 to cascade and enable irq for timer 1 and set its count to 0xffff-samples count. Your irq handler should stop the sound by disabling timer 0 and the dma channel(s).</p>
<pre><code class="language-C">#include &quot;gba.h&quot;

//the sample. its a pcm wave file converted to an elf file with objcopyroda.exe (devrs.com/gba)
extern const u32 _binary_lo1234_pcm_start[];

//the interrupt handler from crt0.s
void InterruptProcess(void) __attribute__((section(&quot;.iwram&quot;)));

void InterruptProcess(void) {
    //sample finished!,stop Direct sound
    REG_TM0CNT_H = 0; //disable timer 0
    REG_DMA1CNT_H = 0; //stop DMA

    //clear the interrupt(s)
    REG_IF |= REG_IF;


void AgbMain(void) {
    //play a mono sound at 16khz
    //uses timer 0 as sampling rate source
    //uses timer 1 to count the samples played in order to stop the sound

    //enable DS A&amp;B + fifo reset + use timer0 + max volume to L and R
    REG_SOUNDCNT_H = 0x0b0F;
    //turn sound chip on
    REG_SOUNDCNT_X = 0x0080;

    //dma1 source
    REG_DMA1SAD = (unsigned long) _binary_lo1234_pcm_start;
    //write to FIFO A address
    REG_DMA1DAD = 0x040000a0;
    //dma control: DMA enabled+ start on FIFO+32bit+repeat+increment source&amp;dest
    REG_DMA1CNT_H = 0xb600;

    //0xffff-the number of samples to play
    REG_TM1CNT_L = 0x7098;
    //enable timer1 + irq and cascade from timer 0
    REG_TM1CNT_H = 0xC4;

    //enable irq for timer 1
    REG_IE = 0x10;
    //master enable interrupts
    REG_IME = 1;

    //Formula for playback frequency is: 0xFFFF-round(cpuFreq/playbackFreq)

    //16khz playback freq
    REG_TM0CNT_L = 0xFBE8;
    //enable timer0
    REG_TM0CNT_H = 0x0080;

}
</code></pre>
<p>True stereo output is a simple extension of the above code:</p>
<ul>
<li>Set REG_SOUNDCNT_H to send DS A to right output and DS B to left output</li>
<li>Set DMA1 source to the right buffer, and destination to DS A FIFO</li>
<li>Set DMA2 source to the left buffer, and destination to DS B FIFO</li>
<li>Set timer 0 as sampling rate source for both DS A&amp;B</li>
</ul>
<h2 id="interrupt-mode-direct-sound-example"><a class="header" href="#interrupt-mode-direct-sound-example">Interrupt Mode Direct Sound Example</a></h2>
<p>DMA mode Direct Sound has reportedly being causing problems in multi-players games. This is because during DMA tranfers, if interrupts occurs, they are only processed upon completion of that DMA. That means possible transmission losses due to bytes in the serial buffer being overwitten before beign read. On possible solution to this problem would be the use of Interrupt mode Direct sound playback. In this mode you set a timer (again 0 or 1), to the sampling frequency, set it to generate interrupts and load the FIFO(s) in the interrupt handler. Note that this methodology might impose problems if interrupts are blocking (ie. not allowing multiple interrupts at once), however if several interrupts at once are allowed inside the handler, this should resolve the issue.</p>
<p>To use Direct sound in Interrupt mode:</p>
<ul>
<li>Set DS ouputs and volume</li>
<li>Set timer 0 frequency to 0xffff</li>
<li>Enable timer 0, set it to generate IRQs and set the clock divider to 1024 (gives 16384 hz )</li>
<li>In the interrupt handler:
<ul>
<li>Load FIFO(s) each 4 samples with 4 bytes</li>
<li>Increment the sample counter</li>
<li>Stop timer 0 when sample end has be reached</li>
</ul>
</li>
</ul>
<pre><code class="language-C">#include &quot;gba.h&quot;

//the sample. its an pcm wave file converted to an elf file with objcopyroda.exe (devrs.com/gba)
extern const u32 _binary_lo1234_pcm_start[];
//the interrupt handler from crt0.s
void InterruptProcess(void) __attribute__((section(&quot;.iwram&quot;)));

int iNextSample = 0;
int SampleSize = 36712;

void InterruptProcess(void) {
  //load FIFO each 4 samples with 4 bytes
  if (!(iNextSample &amp; 3)) REG_SGFIFOA = _binary_lo1234_pcm_start[iNextSample &gt;&gt; 2];

  iNextSample++;

  if (iNextSample &gt; SampleSize) {
    //sample finished!
    REG_TM0CNT_H = 0; //disable timer 0
  }
  //clear the interrupt(s)
  REG_IF |= REG_IF;
}

void AgbMain(void) {
    //play a sample at 16Khz using interrupt mode

    //DirectSound A + fifo reset + max volume to L and R
    REG_SOUNDCNT_H = 0x0B0F;

    //turn sound chip on
    REG_SOUNDCNT_X = 0x0080;

    //enable timer 0 irq
    REG_IE = 0x8;
    //enable interrupts
    REG_IME = 1;

    /*set playback frequency. note: using anything else thank clock multipliers to serve as sample frequencies tends to generate distortion in the output. It has probably to do with timing and FIFO reloading. More testing need to be done. */

    REG_TM0CNT_L = 0xffff;
    //enable timer at CPU freq/1024 +irq =16384Khz sample rate
    REG_TM0CNT_H = 0x00C3;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-channel-1"><a class="header" href="#sound-channel-1">Sound Channel 1</a></h1>
<p>Sound channel 1 produces square waves with variable duty cycle, frequency sweep and envelope functions. It is often referred as a quadrangular wave pattern.</p>
<p>Frequency sweeps allows &quot;portamento&quot;-like effects where the frequency raises or decreases during playback. The amount of increase or decrease in frequency (or sweep shifts) and the rate at which it occurs (sweep time) is controllable. Frequency sweeps are controlled by REG_SOUND1CNT_L</p>
<p>Sweep shifts are controlled by bits 0-2 and are calculated with the following formula:</p>
<p>\( T = T \pm \frac{T}{2^n} \) where T = Wave Period and n = Sweep Shifts</p>
<p>Sweep time (Ts) controls the delay between sweep shifts and is controlled by bits 4-6:</p>
<ul>
<li>000: Sweep function is off</li>
<li>001: Ts=1 / 128Khz (7.8 ms)</li>
<li>010: Ts=2 / 128Khz (15.6 ms)</li>
<li>011: Ts=3 / 128Khz (23.4 ms)</li>
<li>100: Ts=4 / 128Khz (31.3 ms)</li>
<li>101: Ts=5 / 128Khz (39.1 ms)</li>
<li>110: Ts=6 / 128Khz (46.9 ms)</li>
<li>111: Ts=7 / 128Khz (54.7 ms)</li>
</ul>
<p>At each sweep shift, frequency can either increase (bit 3=0) or decrease (bit 3=1).</p>
<p>Next is an example of frequency sweeps when REG_SOUND1CNT_L=0x0079 (sweep shifts=1 and sweep time=54.7 ms) and the initial frequency from REG_SOUND1CNT_X=0x0400 (~128Hz, 7.8 ms period).</p>
<p><img src="audio/images/sweeps.gif" alt="Sweeps example" /></p>
<p>In the above example, frequency decreases gradually. Note that sweep shifts are repeatedly performed until the new value becomes either less than 0 (the previous value is then retained) or, when incrementing, if the new frequency value exceeds the maximum frequency (131Khz or 2048 in register value). In the latter case, the sound would then stop and DMG Sound 1 status bit from REG_SOUNDCNT_X would be reset. When either sweep shifts or sweep time is zero, the frequency remains unchanged. When the sweep function is not required, set sweep shifts and sweep time to zero and set the increase/decrease bit to 1 or otherwise, sometimes, no sound will be played.</p>
<p>The envelope function allows for fade-ins or fade-outs of the sound. It has a 4-bit resolution so it can produce 16 different amplitude levels (steps). The delay between step change (step time) is controlled by bits 8-10 of REG_SOUND1CNT_H. The duration of one step is given by: T= step time*(1/64) sec, hence a maximum fade time of ~1.64 seconds. When the step time is 0, the envelope function is disabled.</p>
<p>Bit 11 of REG_SOUND1CNT_H controls the envelope direction: 0=envelope decreases and 1=envelope increases.</p>
<p>The initial value of the envelope is stored in bits 12-15 of REG_SOUND1CNT_H. When decreasing, if the volume reaches 0000, the sound is muted. When increasing, if the volume reaches 1111, the envelope function stops and the volume remains at that level.</p>
<p><img src="audio/images/envelope.gif" alt="Envelope example" /></p>
<p>Envelope example for REG_SOUND1CNT_H=0x7400</p>
<p>Sound 1 can be set to either play for a specified duration or continuously. This is controlled by bit 14 of REG_SOUND1CNT_X. When set to 0 (continuous mode), sound is played continuously regardless of the length data in REG_SOUND1CNT_H. When set to 1 (timed mode), sound is played for that specified length and after that the DMG Sound 1 status bit of REG_SOUNDCNT_X is reset.</p>
<p>The sound length (bits 0-5 of REG_SOUND1CNT_H) is a value obtained from the following formula:</p>
<p><strong>Sound length = (64-register value)*(1/256) seconds</strong></p>
<p>When using timed mode, after the sound length has be changed, the sound channel must be resetted via bit 15 of REG_SOUND1CNT_X.</p>
<p>Frequency (bits 0-10 of REG_SOUND1CNT_X) can be calculated from the following formula:</p>
<p><strong>F(Hz) = 4194304/(32*(2048-register value)). The minimum frequency is 64Hz and the maximum is 131Khz.</strong></p>
<p>The duty cycle is the ratio of the duration (time) that a signal is ON versus the total period of the signal. The longer it is ON the greater the duty cycle. Sound channel 1 support 4 different duty cycles, which produces very distinctive sounds. Duty cycle is controlled by bit 6-7 of REG_SOUND1CNT_H.</p>
<p>Possible duty cycles:</p>
<p><img src="audio/images/waveduty.gif" alt="Wave duty example" /></p>
<p>All parameters can be changed dynamically while the sound is playing. The envelope initial volume parameter does not have any effects (except when set to zero) until the sound is resetted. Also, resetting the sound does not reset the oscillator (i.e.:square wave pattern is continuous) although the period is slightly longer for the cycle generated during reset (usually +~500us).</p>
<h2 id="sound-channel-1-demo"><a class="header" href="#sound-channel-1-demo">Sound Channel 1 Demo</a></h2>
<p><img src="audio/images/demos1.gif" alt="Demo 1 example" /></p>
<p>A comprehensive demo is included. It shows all features of sound channel 1. The demo also allows to change the resampling frequency bit contained in REG_SOUNDBIAS. Its effects, at least on channel 1, is admittedly very subtle if not unnoticeable.</p>
<pre><code class="language-C">#include &lt;gba.h&gt;

void AgbMain(void) {
  //Play a sound on channel 1

  //turn on sound circuit
  REG_SOUNDCNT_X = 0x80;
  //full volume, enable sound 1 to left and right
  REG_SOUNDCNT_L = 0x1177;
  // Overall output ratio - Full
  REG_SOUNDCNT_H = 2;

  //sweep shifts=6, increment, sweep time=39.1ms
  REG_SOUND1CNT_L = 0x0056;

  //duty=50%,envelope decrement
  REG_SOUND1CNT_H = 0xf780;
  //frequency=0x0400, loop mode
  REG_SOUND1CNT_X = 0x8400;

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-channel-2"><a class="header" href="#sound-channel-2">Sound Channel 2</a></h1>
<p>Sound channel 2 produces square waves with variable duty cycle and envelope functions. Channel 2 is identical to channel 1 but without the frequency sweep function.</p>
<p>The envelope function allows for fade-ins or fade-outs of the sound. It has a 4-bit resolution so it can produce 16 different amplitude levels (steps). The delay between step change (step time) is controlled by bits 8-10 of REG_SOUND2CNT_L. The duration of one step is given by: T= step time*(1/64) sec, hence a maximum fade time of ~1.64 seconds. When the step time is 0, the envelope function is disabled.</p>
<p>Bit 11 of REG_SOUND2CNT_L controls the envelope direction: 0=envelope decreases and 1=envelope increases.</p>
<p>The initial value of the envelope is stored in bits 12-15 of REG_SOUND2CNT_L. When decreasing, if the volume reaches 0000, the sound is muted. When increasing, if the volume reaches 1111, the envelope function stops and the volume remains at that level.</p>
<p><img src="audio/images/envelope.gif" alt="Envelope example" /></p>
<p>Envelope example for REG_SOUND2CNT_L=0x7400.</p>
<p>Sound 2 can be set to either play for a specified duration or continuously. This is controlled by bit 14 of REG_SOUND2CNT_H. When set to 0 (continuous mode), sound is played continuously regardless of the length data in REG_SOUND2CNT_L. When set to 1 (timed mode), sound is played for that specified length and after that the DMG Sound 2 status bit of REG_SOUNDCNT_X is reset.</p>
<p>The sound length (bits 0-5 of REG_SOUND2CNT_L) is a value obtained from the following formula:</p>
<p><strong>Sound length = (64-register value)*(1/256) seconds</strong></p>
<p>When using timed mode, after the sound length has be changed, the sound channel must be resetted via bit 15 of REG_SOUND2CNT_H.</p>
<p>Frequency (bits 0-10 of REG_SOUND2CNT_H) can be calculated from the following formula:</p>
<p><strong>F(Hz) = 4194304/(32*(2048-register value)). The minimum frequency is 64Hz and the maximum is 131Khz.</strong></p>
<p>The duty cycle is the ratio of the duration (time) that a signal is ON versus the total period of the signal. The longer it is ON the greater the duty cycle. Sound channel 1 support 4 different duty cycles, which produces very distinctive sounds. Duty cycle is controlled by bit 6-7 of REG_SOUND2CNT_L.</p>
<p>Possible duty cycles:</p>
<p><img src="audio/images/waveduty.gif" alt="Wave duty example" /></p>
<p>All parameters can be changed dynamically while the sound is playing. The envelope initial volume parameter does not have any effects (except when set to zero) until the sound is resetted. Also, resetting the sound does not reset the oscillator (i.e.:square wave pattern is continuous) although the period is slightly longer for the cycle generated during reset (usually +~500us).</p>
<h2 id="sound-channel-2-demo"><a class="header" href="#sound-channel-2-demo">Sound Channel 2 Demo</a></h2>
<p><img src="audio/images/demos1.gif" alt="Demo 1 example" /></p>
<pre><code class="language-C">#include &lt;gba.h&gt;

void AgbMain(void) {
  //Play a sound on channel 2

  //turn on sound circuit
  REG_SOUNDCNT_X = 0x80;
  //full volume, enable sound 2 to left and right
  REG_SOUNDCNT_L = 0x2277;
  // Overall output ratio - Full
  REG_SOUNDCNT_H = 2;

  //duty=50%,envelope decrement
  REG_SOUND2CNT_L = 0xf780;
  //frequency=0x0400, loop mode
  REG_SOUND2CNT_H = 0x8400;

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-channel-3"><a class="header" href="#sound-channel-3">Sound Channel 3</a></h1>
<p>Channel 3 acts as a 4-bit DAC that repeatadely plays a pattern of samples. This pattern is user definable and consists of sixty-four 4-bit samples, separated in two banks and located from 0x04000090 to 0x0400009F. Channel 3 can play banks in two modes: As a single 64 samples bank or two 32 samples banks. The dual bank mode has the advantage of not needing a sound reset/restart when switching the playing bank. This allows for dynamic reloading of the wave ram without generating distortion as it was the case with previous Gameboys. Bank mode is controlled by bit 5 of REG_SOUND3CNT_L (0x0400070) and resetting it to 0 specifies dual bank mode. Bit 6 controls which bank is active for playing/reloading. If set to 0, samples are played from bank 0 and writing to the Wave Ram will store the data in Bank 1 and vice-versa.</p>
<p>When bit 7 is set and Initial flag (Bit 15) from REG_SOUND3CNT_X is set, the wave pattern starts to play. Both banks of Wave Ram are filled with zero upon initialization of the Gameboy, Bank 0 being selected. So writing to bank 0 implie setting bit 6 to 1 before loading Wave Ram then set it back to 0 to play it. Most emulator currently ignore banks.</p>
<p>Sound 3 can be set to either play for a specified duration (max 1 second) or continuously. This is controlled by bit E of REG_SOUND3CNT_H (0x0400074). When set to 0, sound 3 is played continuously regardless of the length data in REG_SOUND3CNT_H. When set to 1, sound is played for that specified length and after that, bit 2 of REG_SOUNDCNT_X is reset.</p>
<p>The sound length is a 8 bit value obtained from the following formula:</p>
<p><strong>Register = Note lenght(in seconds)*256, hence a 1 second maximum And a 3.9 millisecond minimum sound duration.</strong></p>
<p>After the sound length has be changed, the sound channel must be resetted via bit F of REG_SOUND3CNT_H.</p>
<p>Frequency can be calculated from the following formula:</p>
<p><strong>F(hz) = 4194304/(32*(2048-register value)). The minimum frequency is 64Hz and the maximum is 131Khz.</strong></p>
<p>When the sound is reset, it restarts at the specified frequency. Frequency setting and sound reset must be performed in a single write since both are write only. Note that in continuous mode, frequency can be changed without resetting the sound channel (the reset bit is ignored).</p>
<h2 id="sound-channel-3-demo"><a class="header" href="#sound-channel-3-demo">Sound Channel 3 Demo</a></h2>
<p><img src="audio/images/demo3.gif" alt="Demo 3 example" /></p>
<p>A comprehensive demo is included. It shows most features of channel 3. The demo also explores two ways of stopping the sound while its playing. The counter mode, where sound stops after the time specified in the sound lenght register, and interrupt mode, where an timer interrupt stop the sound after a period of time. The problem with counter mode is that the sound channel must be resetted before restarting another note. This causes very annoying audio artefacts as demonstrated in the following picture:</p>
<p><img src="audio/images/sound3reset.gif" alt="Sound 3 Reset example" /></p>
<p>We can cleary see spikes at the end and start of the sound. In the demo select voice 1 and press start to swap between stop modes. When in counter mode, the clicks are clearly evident.</p>
<p>We can set a timer interrupt to stop sound after a period of time. In the handler, we stop sound by clearing channel 3's play bit or setting its volume to zero. But both approaches tends to distort the sound, though less severely than counter mode. Here's the effect:</p>
<p><img src="audio/images/chan3wavstop.gif" alt="Chan 3 Wav Stop example" /></p>
<p>Using the main sound output control register REG_SOUNDCNT_L, and clear the left/right output bits gives the best results.</p>
<pre><code class="language-C">#include &lt;gba.h&gt;

void AgbMain(void) {
  //Play a continuous tone using channel 3

  //turn on sound circuit
  REG_SOUNDCNT_X = 0x80;
  //full volume, enable sound 3 to left and right
  REG_SOUNDCNT_L = 0x4477;
  // Overall output ratio - Full
  REG_SOUNDCNT_H = SOUND3OUTPUT1;

  //select bank 0 for writing (bank 1 playing)
  REG_SOUND3CNT_L = SOUND3BANK32 | SOUND3SETBANK1;
  //load the wave ram bank 0
  REG_WAVE_RAM0 = 0x10325476;
  REG_WAVE_RAM1 = 0x98badcfe;
  REG_WAVE_RAM2 = 0x10325476;
  REG_WAVE_RAM3 = 0x98badcfe;
  //select bank 0 for playing
  REG_SOUND3CNT_L = SOUND3BANK32 | SOUND3SETBANK0;

  REG_SOUND3CNT_L |= SOUND3PLAY;
  REG_SOUND3CNT_H = SOUND3OUTPUT1;
  //play a C-4 in loop mode
  REG_SOUND3CNT_X = SOUND3INIT | SOUND3PLAYLOOP | 1046;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-channel-4"><a class="header" href="#sound-channel-4">Sound Channel 4</a></h1>
<p>Sound channel 4 produces Pseudo-Noise with an envelope function. Noise is generated by a polynomial counter also known as a Linear-Feedback Shift Register (LFSR). LFSRs are special type of binary counter that have the particularity of not counting in the normal binary increment/decrement sequence. These counters find common uses in pseudorandom-numbers generation. Theory behind LFSRs and Polynomial counters are out of the scope of this document but a simple approach to key concepts will be described. Good references on the subjects are given at the end of this document.</p>
<p>The pseudo-noise pattern playback frequency can be controlled by a 3-bit clock divider used to divide the Sound system's clock (4.194304Mhz). The clock divider's output is then fed into a pre-scaler which output is then used as the polynomial counter's clock. The counter can be set to user either 7 or 15 stages/steps. Resulting into a 127 or 32767 input clock cycle period. Using 7 stages give more metallic sounding effects when played faster (lower divider ratios) while 15 stages sounds much like white noise.</p>
<p>Selection of the clock divider is done by bits 0-2 of REG_SOUND4CNT_H, where f=4.194304 Mhz/8:</p>
<ul>
<li>000: f*2</li>
<li>001: f</li>
<li>010: f/2</li>
<li>011: f/3</li>
<li>100: f/4</li>
<li>101: f/5</li>
<li>110: f/6</li>
<li>111: f/7</li>
</ul>
<p>Bit 3 of REG_SOUND4CNT_H control the number of counter stages: 0=15 stages, 1=7 stages.</p>
<p>Selection of the pre-scaler divider value is done by bits 4-7 of REG_SOUND4CNT_H, where Q is the clock divider's output:</p>
<ul>
<li>0000: Q/2</li>
<li>0001: Q/2^2</li>
<li>0010: Q/2^3</li>
<li>0011: Q/2^4</li>
<li>....</li>
<li>1101: Q/2^14</li>
<li>1110: Not used</li>
<li>1111: Not used</li>
</ul>
<p>The REG_SOUND4CNT_L contains the envelope function and the sound's length and its functionality is identical to channel 1.</p>
<p>Bit 14 of REG_SOUND4CNT_H control the loop/timed mode. If set to 1 sound plays for the duration specified in REG_SOUND4CNT_L otherwise sound plays continuously. Bit 15 resets the sound and the LSFR counter.</p>
<p>All registers can be modified during playback but sound need to be reinitialized when modifying the envelope initial volume or the clock divider for changes to take effects.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>This section is more intended to emulator writers who wants to implement the exact sound of the original Gameboy sound system.</p>
<p>An LFSR counter with n stages can implement a maximum of (2^n)-1 states, n representing the degree of the polynomial. All zeros state is not allowed because it locks the counters. Each state in the entire count sequence is generated once and only once.</p>
<p>The Gameboy sound circuit implements a switchable 7/15-stages LFSR. Below is an representation of the logic used by the Gameboy. It is important to realize that channel 4 does not generate white noise per-se but Pseudo-noise. White noise is a special type of signal containing an equal amount of all frequencies and has no cycle period. LFSR counters have a cycle period of (2^n)-1 input clock cycles. Played at high speed, the pattern starts to exhibit a fundamental derived from the input clock frequency. This is clearly evident when using the 7-stages mode since the cycle is only 127 input clocks. 15-stages mode has a much bigger cycle, 32767, so the pseudo-noise sounds much more like white noise.</p>
<p><img src="audio/images/lfsr.gif" alt="LSFR example" /></p>
<p>When initialized, all shift registers are set to 1. On each clock pulse, bits are shifted from left to right (on the picture) s1 being the least significant bit and the output that is sent to the channel's envelope generator. The count sequence for the 7-stage LFSR, once the sound channel is resetted is then:</p>
<p><strong>Counter steps</strong></p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<p><img src="audio/images/lfsroutput.gif" alt="LFSR output example" /></p>
<p>By looking at s1 output (the the least significant bit), we can see it matches the pattern on the picture, which is a capture of the GBA output for channel 4 in 7-stage mode. Since the counter is always counting in the same sequence, the output bits can be stored in a lookup table for fast emulation of this function. By packing the bits, a 4 KB lookup table is sufficient to represent all states for both the 7 and 15 stages of the LFSR.</p>
<h3 id="references"><a class="header" href="#references">References</a></h3>
<p><a href="http://www.eecircle.com/applets/009/LFSR.html">n-Stage LFSR simulator Java applet</a></p>
<p><a href="http://archives.e-insite.net/archives/ednmag/reg/1996/010496/01df4.htm">EDN article on LFSR</a></p>
<p><a href="http://www-math.cudenver.edu/%7Ewcherowi/courses/m5410/m5410fsr.html">Theory behind LFSR</a></p>
<pre><code class="language-C">#include &lt;gba.h&gt;

void AgbMain(void) {
  //Play a sound on channel 4

  //turn on sound circuit
  REG_SOUNDCNT_X = 0x80;
  //full volume, enable sound 4 to left and right
  REG_SOUNDCNT_L = 0x4477;
  // Overall output ratio - Full
  REG_SOUNDCNT_H = 2;


  //envellope decay, initial vol max
  REG_SOUND4CNT_L = 0xf700;
  //Loop mode, clk div:6, 7-stage,pre-scaler:3
  REG_SOUND4CNT_H = 0x8032;

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gba-sound-registers"><a class="header" href="#gba-sound-registers">GBA Sound Registers</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Adress</th><th>Name</th><th>Function</th></tr></thead><tbody>
<tr><td>0x04000060</td><td>REG_SOUND1CNT_L</td><td>Sound 1 Sweep control</td></tr>
<tr><td>0x04000062</td><td>REG_SOUND1CNT_H</td><td>Sound 1 Length, wave duty and envelope control</td></tr>
<tr><td>0x04000064</td><td>REG_SOUND1CNT_X</td><td>Sound 1 Frequency, reset and loop control</td></tr>
<tr><td>0x04000068</td><td>REG_SOUND2CNT_L</td><td>Sound 2 Lenght, wave duty and envelope control</td></tr>
<tr><td>0x0400006C</td><td>REG_SOUND2CNT_H</td><td>Sound 2 Frequency, reset and loop control</td></tr>
<tr><td>0x04000070</td><td>REG_SOUND3CNT_L</td><td>Sound 3 Enable and wave ram bank control</td></tr>
<tr><td>0x04000072</td><td>REG_SOUND3CNT_H</td><td>Sound 3 Sound lenght and output level control</td></tr>
<tr><td>0x04000074</td><td>REG_SOUND3CNT_X</td><td>Sound 3 Frequency, reset and loop control</td></tr>
<tr><td>0x04000078</td><td>REG_SOUND4CNT_L</td><td>Sound 4 Length, output level and envelope control</td></tr>
<tr><td>0x0400007C</td><td>REG_SOUND4CNT_H</td><td>Sound 4 Noise parameters, reset and loop control</td></tr>
<tr><td>0x04000080</td><td>REG_SOUNDCNT_L</td><td>Sound 1-4 Output level and Stereo control</td></tr>
<tr><td>0x04000082</td><td>REG_SOUNDCNT_H</td><td>Direct Sound control and Sound 1-4 output ratio</td></tr>
<tr><td>0x04000084</td><td>REG_SOUNDCNT_X</td><td>Master sound enable and Sound 1-4 play status</td></tr>
<tr><td>0x04000088</td><td>REG_SOUNDBIAS</td><td>Sound bias and Amplitude resolution control</td></tr>
<tr><td>0x04000090</td><td>REG_WAVE_RAM0_L</td><td>Sound 3 samples 0-3</td></tr>
<tr><td>0x04000092</td><td>REG_WAVE_RAM0_H</td><td>Sound 3 samples 4-7</td></tr>
<tr><td>0x04000094</td><td>REG_WAVE_RAM1_L</td><td>Sound 3 samples 8-11</td></tr>
<tr><td>0x04000096</td><td>REG_WAVE_RAM1_H</td><td>Sound 3 samples 12-15</td></tr>
<tr><td>0x04000098</td><td>REG_WAVE_RAM2_L</td><td>Sound 3 samples 16-19</td></tr>
<tr><td>0x0400009A</td><td>REG_WAVE_RAM2_H</td><td>Sound 3 samples 20-23</td></tr>
<tr><td>0x0400009C</td><td>REG_WAVE_RAM3_L</td><td>Sound 3 samples 23-27</td></tr>
<tr><td>0x0400009E</td><td>REG_WAVE_RAM3_H</td><td>Sound 3 samples 28-31</td></tr>
<tr><td>0x040000A0</td><td>REG_FIFO_A_L</td><td>Direct Sound channel A samples 0-1</td></tr>
<tr><td>0x040000A2</td><td>REG_FIFO_A_H</td><td>Direct Sound channel A samples 2-3</td></tr>
<tr><td>0x040000A4</td><td>REG_FIFO_B_L</td><td>Direct Sound channel B samples 0-1</td></tr>
<tr><td>0x040000A6</td><td>REG_FIFO_B_H</td><td>Direct Sound channel B samples 2-3</td></tr>
</tbody></table>
</div>
<h2 id="dmg-sound-output-control"><a class="header" href="#dmg-sound-output-control">DMG Sound Output Control</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x080</td><td>REG_SOUNDCNT_L</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>2-0</td><td>DMG Left Volume</td><td>RW</td></tr>
<tr><td>3</td><td>Vin to Left on/off (?)</td><td></td></tr>
<tr><td>6-4</td><td>DMG Right Volume</td><td>RW</td></tr>
<tr><td>7</td><td>Vin to Right on/off (?)</td><td></td></tr>
<tr><td>8</td><td>DMG Sound 1 to left output</td><td>RW</td></tr>
<tr><td>9</td><td>DMG Sound 2 to left output</td><td>RW</td></tr>
<tr><td>A</td><td>DMG Sound 3 to left output</td><td>RW</td></tr>
<tr><td>B</td><td>DMG Sound 4 to left output</td><td>RW</td></tr>
<tr><td>C</td><td>DMG Sound 1 to right output</td><td>RW</td></tr>
<tr><td>D</td><td>DMG Sound 2 to right output</td><td>RW</td></tr>
<tr><td>E</td><td>DMG Sound 3 to right output</td><td>RW</td></tr>
<tr><td>F</td><td>DMG Sound 4 to right output</td><td>RW</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>This register controls only the DMG output amplifiers and have no effects on the individual sound channels processing, or Direct Sound channels volume.</li>
<li>Vin Left/Right were used on the original gameboy to enable gamepaks to provide their own sound source. It is currently unknown if this function is still supported and working on the GBA.</li>
</ol>
<h2 id="direct-sound-output-control-register-1"><a class="header" href="#direct-sound-output-control-register-1">Direct Sound Output Control Register</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x082</td><td>REG_SOUNDCNT_H</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>1-0</td><td>Output sound ratio for chan. 1-4 (0=25%,1=50%,2=100%)</td><td>RW</td></tr>
<tr><td>2</td><td>Direct sound A output ratio (0=50%, 1=100%)</td><td>RW</td></tr>
<tr><td>3</td><td>Direct sound B output ratio (0=50%, 1=100%)</td><td>RW</td></tr>
<tr><td>7-4</td><td>Unused</td><td></td></tr>
<tr><td>8</td><td>Direct sound A to right output</td><td>RW</td></tr>
<tr><td>9</td><td>Direct sound A to left output</td><td>RW</td></tr>
<tr><td>A</td><td>Direct sound A Sampling rate timer (timer 0 or 1)</td><td>RW</td></tr>
<tr><td>B</td><td>Direct sound A FIFO reset</td><td>RW</td></tr>
<tr><td>C</td><td>Direct sound B to right output</td><td>RW</td></tr>
<tr><td>D</td><td>Direct sound B to left output</td><td>RW</td></tr>
<tr><td>E</td><td>Direct sound B Sampling rate timer (timer 0 or 1)</td><td>RW</td></tr>
<tr><td>F</td><td>Direct sound B FIFO reset</td><td>RW</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>Output ratios control the output volume. Use when DMG channels or Direct Sound plays too loud relative to each other.</li>
<li>Direct Sound is a dual 8-bit DAC fed by data located in two FIFOs. FIFOs can be loaded manually or automatically in DMA mode when set appropriately. The DMA mode uses the timers specified in bits A and E as the sampling frequency reference. A single timer can be used for both DirectSound A&amp;B. However, 2 DMA channels (1&amp;2) must be used to output two different sounds simultaneously on both channels. Also, DMA channel start mode must be set to 11 to instruct it to repeat on FIFO-empty requests.</li>
</ol>
<h2 id="master-sound-output-controlstatus"><a class="header" href="#master-sound-output-controlstatus">Master Sound Output Control/Status</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x084</td><td>REG_SOUNDCNT_X</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>0</td><td>DMG Sound 1 status</td><td>R</td></tr>
<tr><td>1</td><td>DMG Sound 2 status</td><td>R</td></tr>
<tr><td>2</td><td>DMG Sound 3 status</td><td>R</td></tr>
<tr><td>3</td><td>DMG Sound 4 status</td><td>R</td></tr>
<tr><td>6-4</td><td>Unused</td><td></td></tr>
<tr><td>7</td><td>All sound circuit enable (0=off, 1=on)</td><td>RW</td></tr>
<tr><td>F-8</td><td>Unused</td><td></td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>Bits 0-3 are set when their respective sound channels are playing and are resetted when sound has stopped. Note that contrary to some other sources and most emulators, these bits are read-only and do not need to be set to enable the sound channels.</li>
<li>Bit 7 turns on or off the entire sound circuit (DMG and Direct Sound). Keep this bit cleared as often as possible in order to save battery power. Some sources states that it allows batteries to last up to 10% longer.</li>
</ol>
<h2 id="sound-bias"><a class="header" href="#sound-bias">Sound Bias</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x088</td><td>REG_SOUNDBIAS</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>9-0</td><td>DC offset bias value</td><td>RW</td></tr>
<tr><td>D-A</td><td>Unused</td><td></td></tr>
<tr><td>F-E</td><td>PWM resampling resolution where: <br> 00=9bit at 32768 Hz <br> 01= 8bit at 65536 Hz <br> 10=7bit at 131072 Hz <br> 11= 6bit at 262144 Hz</td><td>RW</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>The BIAS setting is used to offset the sound output and bring it back into a signed range. When the BIOS starts up, it runs a timing loop where it slowly raises the BIAS voltage from 0 to 512. This setting should not be changed. At best, the sound will become distorted. At worst the amplifier inside the GBA could be damaged. When accessing bits FE, a read-modify-write is required.</li>
<li>The default value for bits FE is 00. Most if not all games, uses 01 for this setting. More research is being done on this register.</li>
</ol>
<h2 id="directsound-fifo-a"><a class="header" href="#directsound-fifo-a">DirectSound FIFO A</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x0A0-0x0A2</td><td>REG_FIFO_A</td></tr>
</tbody></table>
</div>
<h3 id="0x0a0"><a class="header" href="#0x0a0">0x0A0</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>7-0</td><td>8-Bit sample 0</td><td>W</td></tr>
<tr><td>F-8</td><td>8-Bit sample 1</td><td>W</td></tr>
</tbody></table>
</div>
<h3 id="0x0a2"><a class="header" href="#0x0a2">0x0A2</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>7-0</td><td>8-Bit sample 2</td><td>W</td></tr>
<tr><td>F-8</td><td>8-Bit sample 3</td><td>W</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>These registers contains the samples required for Direct Sound channel A output.</li>
<li>Reading from this register yields unpredictable results.</li>
</ol>
<h2 id="directsound-fifo-b"><a class="header" href="#directsound-fifo-b">DirectSound FIFO B</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x0A4-0x0A6</td><td>REG_FIFO_B</td></tr>
</tbody></table>
</div>
<h3 id="0x0a4"><a class="header" href="#0x0a4">0x0A4</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>7-0</td><td>8-Bit sample 0</td><td>W</td></tr>
<tr><td>F-8</td><td>8-Bit sample 1</td><td>W</td></tr>
</tbody></table>
</div>
<h3 id="0x0a6"><a class="header" href="#0x0a6">0x0A6</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>7-0</td><td>8-Bit sample 2</td><td>W</td></tr>
<tr><td>F-8</td><td>8-Bit sample 3</td><td>W</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>These registers contains the samples required for Direct Sound channel B output.</li>
<li>Reading from this register yields unpredictable results.</li>
</ol>
<h2 id="dmg-channel-1-sweep-control"><a class="header" href="#dmg-channel-1-sweep-control">DMG Channel 1 Sweep control</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x60</td><td>REG_SOUND1CNT_L</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>2-0</td><td>Sweep shifts</td><td>RW</td></tr>
<tr><td>3</td><td>Sweep increase/decrease: <br> 0=Addition(frequency increases) <br> 1=Subtraction (frequency decreases)</td><td>RW</td></tr>
<tr><td>6-4</td><td>Sweep time: <br> 000: Sweep function is off <br> 001: Ts=1 / 128Khz (7.8 ms) <br> 010: Ts=2 / 128Khz (15.6 ms) <br> 011: Ts=3 / 128Khz (23.4 ms) <br> 100: Ts=4 / 128Khz (31.3 ms) <br> 101: Ts=5 / 128Khz (39.1 ms) <br> 110: Ts=6 / 128Khz (46.9 ms) <br> 111: Ts=7 / 128Khz (54.7 ms)</td><td>RW</td></tr>
<tr><td>F-7</td><td>Unused</td><td></td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>The sound channel 1 produces a square wave with envelope and frequency sweep functions.</li>
<li>This register controls the frequency sweep function. Sweep shifts bits controls the amount of change in frequency (either increase or decrease) at each change. The wave's new period is given by: \( T = T \pm \frac{T}{2^n} \) where n is the sweep shifts value.</li>
<li>Sweep time is the delay between sweep shifts. After each delay, frequency changes repeatedly.</li>
<li>When decrementing, if the frequency value gets smaller than zero, the previous value is retained. When incrementing, if the frequency gets greater than the maximum frequency (131Khz or 2048 for the register value) the sound stops.</li>
<li>When the sweep function is not required, set the sweep time to zero and set the increase/decrease bit to 1.</li>
<li>When Initializing the sound (REG_SOUND1CNT_X bit F=1) using sweeps, re-initialize the sound after 8 clocks or more. Otherwise the sound may stop.</li>
</ol>
<h2 id="dmg-channel-1-length-wave-duty-and-envelope-control"><a class="header" href="#dmg-channel-1-length-wave-duty-and-envelope-control">DMG Channel 1 Length, Wave Duty and Envelope Control</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x062</td><td>REG_SOUND1CNT_H</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>5-0</td><td>Sound length</td><td>W</td></tr>
<tr><td>7-6</td><td>Wave duty cycle: <br> 00=12.5% <br> 01=25% <br> 10=50% <br> 11=75%</td><td>RW</td></tr>
<tr><td>A-8</td><td>Envelope step time</td><td>RW</td></tr>
<tr><td>B</td><td>Envelope mode: <br> 0=Envelope decreases <br> 1=Envelope increases</td><td>RW</td></tr>
<tr><td>F-C</td><td>Initial envelope value</td><td>RW</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>The sound length is an 6 bit value obtained from the following formula: Sound length= (64-register value)*(1/256) seconds.</li>
<li>After the sound length has been changed, the sound channel must be resetted via bit F of REG_SOUND1CNT_X (when using timed mode).</li>
<li>Wave duty cycle control the percentage of the ON state of the square wave.</li>
<li>The envelope step time is the delay between successive envelope increase or decrease. It is given by the following formula: T=register value*(1/64) seconds.</li>
<li>Envelope mode control if the envelope is to increase or decrease in volume over time.</li>
<li>The initial volume of the envelope is controlled by bit F-C. 1111 produces the maximum volume and 0000 mutes the sound.</li>
</ol>
<h2 id="dmg-channel-1-frequency-reset-and-loop-control"><a class="header" href="#dmg-channel-1-frequency-reset-and-loop-control">DMG Channel 1 Frequency, Reset and Loop Control</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x064</td><td>REG_SOUND1CNT_X</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>A-0</td><td>Sound frequency</td><td>W</td></tr>
<tr><td>D-B</td><td>Unused</td><td></td></tr>
<tr><td>E</td><td>Timed mode: <br> 0=continuous, 1=timed</td><td>RW</td></tr>
<tr><td>F</td><td>Sound Reset</td><td>W</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>Frequency can be calculated from the following formula: F(hz)=4194304/(32*(2048-register value)). The minimum frequency is 64Hz and the maximum is 131Khz.</li>
<li>When Bit E (Timed mode) is set to 0, sound 1 is played continuously regardless of the length data in REG_SOUND1CNT_H. When set to 1, sound is played for that specified length and after that, bit 0 of REG_SOUNDCNT_X is reset.</li>
<li>When bit F is set to 1, the envelope is resetted to its initial value and sound restarts at the specified frequency.</li>
<li>Frequency can always be changed without resetting the sound. However, when in continuous mode, alway set the sound lenght to zero after changing the frequency. Otherwise, the sound may stop.</li>
</ol>
<h2 id="dmg-channel-2-length-wave-duty-and-envelope-control"><a class="header" href="#dmg-channel-2-length-wave-duty-and-envelope-control">DMG Channel 2 Length, Wave Duty and Envelope Control</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x068</td><td>REG_SOUND2CNT_L</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>5-0</td><td>Sound length</td><td>W</td></tr>
<tr><td>7-6</td><td>Wave duty cycle: <br> 00=12.5% <br> 01=25% <br> 10=50% <br> 11=75%</td><td>RW</td></tr>
<tr><td>A-8</td><td>Envelope step time</td><td>RW</td></tr>
<tr><td>B</td><td>Envelope mode: <br> 0=Envelope decreases <br> 1=Envelope increases</td><td>RW</td></tr>
<tr><td>F-C</td><td>Initial envelope value</td><td>RW</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>The sound length is an 6 bit value obtained from the following formula: Sound length= (64-register value)*(1/256) seconds.</li>
<li>After the sound length has been changed, the sound channel must be resetted via bit F of REG_SOUND2CNT_H (when using timed mode).</li>
<li>Wave duty cycle control the percentage of the ON state of the square wave.</li>
<li>The envelope step time is the delay between successive envelope increase or decrease. It is given by the following formula: T=register value*(1/64) seconds.</li>
<li>Envelope mode control if the envelope is to increase or decrease in volume over time.</li>
<li>The initial volume of the envelope is controlled by bit F-C. 1111 produces the maximum volume and 0000 mutes the sound.</li>
</ol>
<h2 id="dmg-channel-2-frequency-reset-and-loop-control"><a class="header" href="#dmg-channel-2-frequency-reset-and-loop-control">DMG Channel 2 Frequency, Reset and Loop Control</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x06C</td><td>REG_SOUND2CNT_H</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>A-0</td><td>Sound frequency</td><td>W</td></tr>
<tr><td>D-B</td><td>Unused</td><td></td></tr>
<tr><td>E</td><td>Timed mode: <br> 0=continuous, 1=timed</td><td>RW</td></tr>
<tr><td>F</td><td>Sound Reset</td><td>W</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>Frequency can be calculated from the following formula: F(Hz)=4194304/(32*(2048-register value)). The minimum frequency is 64Hz and the maximum is 131Khz.</li>
<li>When Bit E (Timed mode) is set to 0, sound 2 is played continuously regardless of the length data in REG_SOUND2CNT_L. When set to 1, sound is played for that specified length and after that, bit 1 of REG_SOUNDCNT_X is reset.</li>
<li>When bit F is set to 1, the envelope is resetted to its initial value and sound restarts at the specified frequency.</li>
<li>Frequency can always be changed without resetting the sound. However, when in continuous mode, alway set the sound lenght to zero after changing the frequency. Otherwise, the sound may stop.</li>
</ol>
<h2 id="dmg-channel-3-enable-and-wave-ram-bank-control"><a class="header" href="#dmg-channel-3-enable-and-wave-ram-bank-control">DMG Channel 3 Enable and Wave RAM Bank Control</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x070</td><td>REG_SOUND3CNT_L</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>4-0</td><td>Unused</td><td></td></tr>
<tr><td>5</td><td>Bank Mode (0=2x32, 1=1x64)</td><td>RW</td></tr>
<tr><td>6</td><td>Bank Select (Non set bank is written to)</td><td>RW</td></tr>
<tr><td>7</td><td>Sound Channel 3 output enable</td><td>RW</td></tr>
<tr><td>F-8</td><td>Unused</td><td></td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>The sound channel 3 is a circuit that can produce an arbitrary wave pattern. Samples are 4 bit, 8 samples per word, and are located in Wave Ram registers from 0x400090 to 0x40009F.</li>
<li>In the Gameboy Advance, the Wave Ram is banked, providing the ability to play a 64 samples pattern or to select between two 32 samples patterns (Bit 5). Sound channel 3 always produces some audio artifacts (distortion) when sound is initialized. Fortunately, switching banks does not require re-initialisation during playback, thus allowing for dynamic reloading of the Wave Ram without generating any distortion.</li>
<li>Bit 6 controls which bank is active for playing/reloading. If set to 0, samples are played from bank 0 and writing to the Wave Ram will store the data in Bank 1 and vice-versa.</li>
<li>When bit 7 is set and Initial flag (Bit 15) from REG_SOUND3CNT_X is set, the wave pattern starts to play.</li>
<li>Both banks of Wave Ram are filled with zero upon initialization of the Gameboy, Bank 0 being selected. So writing to bank 0 implies setting bit 6 to 1 before loading Wave Ram then set it back to 0 to play it. Most emulator currently ignore banks.</li>
</ol>
<h2 id="dmg-channel-3-sound-length-and-output-level-control"><a class="header" href="#dmg-channel-3-sound-length-and-output-level-control">DMG Channel 3 Sound Length and Output Level Control</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x072</td><td>REG_SOUND3CNT_H</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>7-0</td><td>Sound length</td><td>W</td></tr>
<tr><td>C-8</td><td>Unused</td><td></td></tr>
<tr><td>F-D</td><td>Ouput volume ratio: <br> 000=Mute <br> 001=100% <br> 100=75% <br> 010=50% <br> 011=25%</td><td>RW</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>The sound length is an 8 bit value obtained from the following formula: Register=Note length(in seconds)*256, hence a 1 second maximum and a 3.9 millisecond minimum sound duration.</li>
<li>After the sound length has be changed, the sound channel must be resetted via bit F of REG_SOUND3CNT_H (when using timed mode).</li>
</ol>
<h2 id="dmg-channel-3-frequency-reset-and-loop-control"><a class="header" href="#dmg-channel-3-frequency-reset-and-loop-control">DMG Channel 3 Frequency, Reset and Loop Control</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x074</td><td>REG_SOUND3CNT_X</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>A-0</td><td>Sound frequency</td><td>W</td></tr>
<tr><td>D-B</td><td>Unused</td><td></td></tr>
<tr><td>E</td><td>Timed mode: <br> 0=continuous, 1=timed</td><td>RW</td></tr>
<tr><td>F</td><td>Sound Reset</td><td>W</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>Frequency can be calculated from the following formula: F(Hz)=4194304/(32*(2048-register value)). The minimum frequency is 64Hz and the maximum is 131Khz.</li>
<li>When Bit E (Timed mode) is set to 0, sound 3 is played continuously regardless of the length data in REG_SOUND3CNT_H. When set to 1, sound is played for that specified length and after that, bit 2 of REG_SOUNDCNT_X is reset.</li>
<li>When bit F is set to 1, sound resets and restarts at the specified frequency. Frequency and sound reset must be performed in a single write since both are write only.</li>
<li>Note that in continuous mode, frequency can be changed without resetting the sound channel. However, when in continuous mode, alway set the sound lenght to zero after changing the frequency. Otherwise, the sound may stop.</li>
</ol>
<h2 id="dmg-channel-3-wave-ram-registers"><a class="header" href="#dmg-channel-3-wave-ram-registers">DMG Channel 3 Wave RAM Registers</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x090-0x09F</td><td>REG_WAVERAM0-3</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>3-0</td><td>4-bit sample 0</td><td>RW</td></tr>
<tr><td>7-4</td><td>4-bit sample 1</td><td>RW</td></tr>
<tr><td>B-8</td><td>4-bit sample 2</td><td>RW</td></tr>
<tr><td>F-C</td><td>4-bit sample 3</td><td>RW</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>Wave ram spans four 32 bit registers.</li>
<li>Take into account that ARM store 32bit words in little-indian format. So if you load REG_WAVERAM0=0x01234567, in reality, the sample played will be 6-7-4-5-2-3-0-1.</li>
</ol>
<h2 id="dmg-channel-4-length-output-level-and-envelope-control"><a class="header" href="#dmg-channel-4-length-output-level-and-envelope-control">DMG Channel 4 Length, Output Level and Envelope Control</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x78</td><td>REG_SOUND4CNT_L</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>5-0</td><td>Sound length</td><td>W</td></tr>
<tr><td>7-6</td><td>Unused</td><td></td></tr>
<tr><td>A-8</td><td>Envelope step time</td><td>RW</td></tr>
<tr><td>B</td><td>Envelope mode: <br> 0=Envelope decreases <br> 1=Envelope increases</td><td>RW</td></tr>
<tr><td>F-C</td><td>Initial envelope value</td><td>RW</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>The sound length is an 6 bit value obtained from the following formula: Sound length= (64-register value)*(1/256) seconds.</li>
<li>After the sound length has been changed, the sound channel must be resetted via bit F of REG_SOUND4CNT_H (when using timed mode).</li>
<li>The envelope step time is the delay between successive envelope increase or decrease. It is given by the following formula: T=register value*(1/64) seconds.</li>
<li>Envelope mode control if the envelope is to increase or decrease in volume over time.</li>
<li>The initial volume of the envelope is controlled by bit F-C. 1111 produces the maximum volume and 0000 mutes the sound.</li>
</ol>
<h2 id="dmg-channel-4-noise-parameters-reset-and-loop-control"><a class="header" href="#dmg-channel-4-noise-parameters-reset-and-loop-control">DMG Channel 4 Noise Parameters, Reset and Loop Control</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Name</th></tr></thead><tbody>
<tr><td>0x07C</td><td>REG_SOUND4CNT_H</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>2-0</td><td>Clock divider frequency (with f=4.194304 Mhz/8) <br> 000: f*2 <br> 001: f <br> 010: f/2 <br> 011: f/3 <br> 100: f/4 <br> 101: f/5 <br> 110: f/6 <br> 111: f/7</td><td>RW</td></tr>
<tr><td>3</td><td>Counter stages: <br> 0=15 stages, 1=7 stages</td><td>RW</td></tr>
<tr><td>7-4</td><td>Counter Pre-Stepper frequency (with Q=clock divider's output frequency): <br> 0000: Q/2 <br> 0001: Q/2^2 <br> 0010: Q/2^3 <br> 0011: Q/2^4 <br> .... <br> 1101: Q/2^14 <br> 1110: Not used <br> 1111: Not used</td><td>RW</td></tr>
<tr><td>D-8</td><td>Unused</td><td></td></tr>
<tr><td>E</td><td>Timed mode: <br> 0=continuous, 1=timed</td><td>RW</td></tr>
<tr><td>F</td><td>Sound Reset</td><td>W</td></tr>
</tbody></table>
</div>
<p><em>Notes</em></p>
<ol>
<li>Channel 4 produces pseudo-noise generated by a polynomial counter. It is based on a 7/15 stages linear-feedback shift register (LFSR). LFSR counts in a pseudo-random order where each state is generated once and only once during the whole count sequence. The sound is produced by the least significant bit's output stage.</li>
<li>A Clock divider controlled by bits 0-2 divides the CPU frequency. Its output is then fed into the counter's pre-scaler (controlled by bits 4-7) which divides further more the frequency.</li>
<li>The Counter stages controls the period of the polynomial counter. It is given by (2^n)-1 where n=number of stages. So for n=7, the pseudo-noise period lasts 63 input clocks. After that, the counter restarts the same count sequence.</li>
<li>When Bit E (Timed mode) is set to 0, sound 4 is played continuously regardless of the length data in REG_SOUND4CNT_L. When set to 1, sound is played for that specified length and after that, bit 3 of REG_SOUNDCNT_X is reset.</li>
<li>When bit F is set to 1, Envelope is set to initial value, the LFSR count sequence is resetted and the sound restarts.</li>
<li>Note that in continuous mode, all parameters can be changed but sound need to be resetted when modifying the envelope initial volume or the clock divider for changes to take effects.</li>
</ol>
<h2 id="acronyms-used"><a class="header" href="#acronyms-used">Acronyms used</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Acronym</th><th>Meaning</th></tr></thead><tbody>
<tr><td>DAC</td><td>Digital-to-Analog Converters</td></tr>
<tr><td>DMA</td><td>Direct Memory Access</td></tr>
<tr><td>DMG</td><td>The original gameboy (Dot Matrix Game)</td></tr>
<tr><td>FIFO</td><td>First-In-First-Out</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="bootleg-carts"><a class="header" href="#bootleg-carts">Bootleg Carts</a></h1>
<p>Bootleg carts, sometimes called repro carts, are illegal game carts sold from China.  At the time of
writing, some members of the GBADev community have purchased them for around $5/cart.</p>
<p>From discussion with store owners in China, these carts cannot be ordered blank -- they are created
with copywritted games already on them (usually the popular games, Pokemon, Mario, etc).</p>
<p>However, these carts <em>can</em> be cleaned and overwritten with homebrew games.</p>
<p>This guide will describe how to develop games for bootleg carts.</p>
<ol>
<li><a href="bootleg-carts/introduction.html#size-of-carts">Size of Carts</a></li>
<li><a href="bootleg-carts/introduction.html#removing-label">Removing Label</a></li>
<li><a href="bootleg-carts/introduction.html#flashing-cart">Flashing Cart</a></li>
<li><a href="bootleg-carts/introduction.html#batteryless-saving">Batteryless Saving</a></li>
<li><a href="bootleg-carts/introduction.html#hardware-used-in-carts">Hardware Used in Carts</a></li>
<li><a href="bootleg-carts/introduction.html#swapping-of-d0d1">Swapping of D0/D1</a></li>
<li><a href="bootleg-carts/introduction.html#understanding-commands">Understanding Commands</a></li>
<li><a href="bootleg-carts/introduction.html#querying-for-information">Querying for Information</a></li>
<li><a href="bootleg-carts/introduction.html#detecting-if-d0d1-are-swapped">Detecting if D0/D1 are Swapped</a></li>
<li><a href="bootleg-carts/introduction.html#understanding-region-layout">Understanding Region Layout</a></li>
<li><a href="bootleg-carts/introduction.html#erasing-a-sector">Erasing a Sector</a></li>
<li><a href="bootleg-carts/introduction.html#saving-data">Saving Data</a></li>
<li><a href="bootleg-carts/introduction.html#final-thoughts">Final Thoughts</a></li>
</ol>
<h2 id="size-of-carts"><a class="header" href="#size-of-carts">Size of Carts</a></h2>
<p>The carts typically range in size from 4MB to 32MB, with 16MB being the most common.</p>
<p>If your game requires a lot of storage space, then you will be more restricted in which carts you
can buy.</p>
<p>For example, <em>Pokemon</em> games come on 16MB carts, and <em>Kingdom of Hearts - Chain of Memories</em> is
32MB.</p>
<h2 id="removing-label"><a class="header" href="#removing-label">Removing Label</a></h2>
<p><img src="bootleg-carts/images/label.jpg" alt="Label Removal - Before and After" /></p>
<p>The carts will arrive with illegal content and label.  Some carts and cases arrive with scuff marks
as well.</p>
<p>To remove the label, first take the cart apart.  You will need a Y0 screw bit, sometimes called a
gamebit.  The <a href="https://www.ifixit.com/Store/Tools/Moray-Driver-Kit/IF145-475">iFixit Moray Driver
Kit</a> contains one, but they can be
found in lots of places.</p>
<p><img src="bootleg-carts/images/back.jpg" alt="Back of Cart" /></p>
<p>Some products that work with removing labels are <a href="https://googone.com/">Goo Gone</a> and
<a href="https://www.wd40.com/">WD-40</a>.</p>
<p>Spray a little bit of the liquid on the label, and wait for it to soak in (Goo Gone takes about
5min).  Then scrap off the label, and wash the plastic with soap and water.</p>
<p><img src="bootleg-carts/images/label-removal.jpg" alt="Label Removal" /></p>
<h2 id="flashing-cart"><a class="header" href="#flashing-cart">Flashing Cart</a></h2>
<p><img src="bootleg-carts/images/flashers.jpg" alt="Flashing Hardware" /></p>
<p>You will need a device to connect the cart to your computer in order to overwrite the contents of
the cart with your game.</p>
<p>Here are some known flashers at the time of writing:</p>
<ul>
<li><a href="https://shop.insidegadgets.com/product/gbxcart-rw/">GBxCart RW</a></li>
<li><a href="https://bennvenn.myshopify.com/collections/cart-flasher-dumper-reader-writer">Joey Jr</a></li>
<li><a href="https://www.epilogue.co/">GB Operator</a></li>
</ul>
<p>I personally like GBxCart RW the best because it works on Mac OSX, runs from the command line, and
is <a href="https://github.com/lesserkuma/FlashGBX">open source</a>.  To flash your game using GBxCart RW,
after installing FlashGBX on your system, you run:</p>
<pre><code class="language-bash">python3 -m FlashGBX --mode agb --action flash-rom MyGame.gba
</code></pre>
<p>Joey Jr works on Windows and doesn't require any installation, since the cart will show up as an
external drive.  You simply drag your game on to the drive in Windows Explorer (or <code>copy</code> from the
command line).</p>
<p>GB Operator has a user interface for playing games off of carts, and is more polished.  Writing
games to flash carts is just one feature.</p>
<p>Your needs may vary, and features may change over time.  Buy the best one that works for you, or
buy all of them :-).  They're pretty cheap.</p>
<h2 id="batteryless-saving"><a class="header" href="#batteryless-saving">Batteryless Saving</a></h2>
<p>The flashers work because the cart ROMs can be overwritten.</p>
<p>In the past, carts used to have batteries installed, in order to support SRAM.  However, this
increases the cost of manufacturing.</p>
<p>As of writing, carts are now manufactured without batteries.  Typically SRAM is available, but
contents won't persist after power off (so it acts as an 8-bit RAM).</p>
<p>So how can a game developer make a game that saves player progress?</p>
<p>By using the same technique that the flashers use - writing data to the ROM itself.</p>
<h2 id="hardware-used-in-carts"><a class="header" href="#hardware-used-in-carts">Hardware Used in Carts</a></h2>
<p><img src="bootleg-carts/images/chips.jpg" alt="Cart Chips" /></p>
<p>In order to flash data to the cart, you will need to know what chips are in the cart.</p>
<p>For this guide, I will assume the cart is using a <code>S29GL128N</code> chip.  You can usually read the chip
by using a magnifying glass and looking at the text stamped on the chip.</p>
<p>If you are interested in the exact specifications of the chip, you will need to track down the data
sheet for it.  <a href="https://github.com/velipso/gvasm/blob/main/mirror/s29glxxxn.pdf">Here is the data sheet for the
S29GL128N</a>.  It will tell you
exactly how to communicate with the chip.</p>
<p>Thankfully, many different chips use the same protocols, so a save routine won't need to know the
exact chip, but instead just a category of chips.</p>
<p>At a high level, flashing to the cart will consist of:</p>
<ol>
<li>Querying the cart for sector layout</li>
<li>Erasing a sector</li>
<li>Writing the data to the sector</li>
</ol>
<p>This is accomplished by writing special values to the ROM, at special address locations.</p>
<h2 id="swapping-of-d0d1"><a class="header" href="#swapping-of-d0d1">Swapping of D0/D1</a></h2>
<p><strong>IMPORTANT NOTE:</strong> Many carts will swap the D0 and D1 lines!</p>
<p>This means when the specification says you need to write <code>0x55</code>, then you actually need to write
<code>0x56</code> because bits 0 and 1 are swapped (<code>01010101</code> -&gt; <code>01010110</code>).</p>
<p>This also affects reading the sector layout, because the values you read will have bits 0 and 1
swapped as well.</p>
<p>This <em>does not</em> affect the data written to the ROM.  If you want <code>0x4321</code> written to memory, then
just write <code>0x4321</code>, because it will be swapped on write, and swapped again on read, cancelling it
out.</p>
<h2 id="understanding-commands"><a class="header" href="#understanding-commands">Understanding Commands</a></h2>
<p>The table on page 57 shows the different commands available for the <code>S29GL128N</code>:</p>
<p><img src="bootleg-carts/images/commands.png" alt="S29GL128N Commands" /></p>
<p>You can see that this information also exists in the FlashGBX source code, <a href="https://github.com/lesserkuma/FlashGBX/blob/9b44a9959bf9fd6bab5f1005ce1c757d2f456fa7/FlashGBX/config/fc_AGB_MSP55LV128M.txt">in the
config</a>:</p>
<pre><code class="language-javascript">&quot;reset&quot;:[
  [ 0, 0xF0 ]
],
&quot;read_identifier&quot;:[
  [ 0xAAA, 0xA9 ],
  [ 0x555, 0x56 ],
  [ 0xAAA, 0x90 ]
],
&quot;read_cfi&quot;:[
  [ 0xAA, 0x98 ]
],
...
</code></pre>
<p>Notice that the &quot;Auto-Select&quot; row doesn't exactly match the <code>&quot;read_identifier&quot;</code> information.</p>
<p>Auto-Select starts with address <code>0xAAA</code>, data <code>0xAA</code>, but FlashGBX has address <code>0xAAA</code>, data
<code>0xA9</code> -- this is because D0/D1 are swapped (<code>10101010</code> -&gt; <code>10101001</code>)!  <a href="bootleg-carts/introduction.html#swapping-of-d0d1">See the section
above</a>.</p>
<p>So if we want to perform a reset on the chip, we just write <code>0xF0</code> to any address.  Note that reset
doesn't <em>erase</em> the chip, it just resets any commands in progress.</p>
<pre><code class="language-c">// reset
*((u16 *)0x08000000) = 0xF0;
__asm(&quot;nop&quot;);
</code></pre>
<p>The forked goombacolor project from LesserKuma has example code, where <a href="https://github.com/lesserkuma/goombacolor/blob/f2bae8eb5087de14008250032c82cf5d294131cd/src/main.c#L585">you can see this
happen</a>:</p>
<pre><code class="language-c">#define _FLASH_WRITE(pa, pd) { *(((u16 *)AGB_ROM)+((pa)/2)) = pd; __asm(&quot;nop&quot;); }

// reset
_FLASH_WRITE(0, 0xF0);
// auto-select
_FLASH_WRITE(0xAAA, 0xA9);
_FLASH_WRITE(0x555, 0x56);
_FLASH_WRITE(0xAAA, 0x90);
</code></pre>
<p><strong>IMPORTANT NOTE:</strong> Since we need to control the reads/writes sent to the ROM, we cannot run the
code from the ROM.  You will need to <a href="https://github.com/lesserkuma/goombacolor/blob/f2bae8eb5087de14008250032c82cf5d294131cd/src/main.c#L553">load the code into
EWRAM</a>
or IWRAM so that the bus between the GBA and the cart doesn't have extra reads to execute code.</p>
<h2 id="querying-for-information"><a class="header" href="#querying-for-information">Querying for Information</a></h2>
<p>There is a standard protocol used by all flash chips called the <a href="https://en.wikipedia.org/wiki/Common_Flash_Memory_Interface">Common Flash Memory
Interface</a> (CFI).</p>
<p>You can use CFI to query a lot of information about the chip you're interacting with.  The chip
specifications should have a section on CFI.</p>
<p>Two things in particular you probably want is whether D0/D1 are swapped, and the region layout.</p>
<h2 id="detecting-if-d0d1-are-swapped"><a class="header" href="#detecting-if-d0d1-are-swapped">Detecting if D0/D1 are Swapped</a></h2>
<p>You can detect if D0/D1 are swapped by putting the chip in CFI mode, then reading the bytes at
<code>0x20</code>, <code>0x22</code>, and <code>0x24</code>.  These values are hardcoded to <code>'Q'</code>, <code>'R'</code>, <code>'Y'</code>, but if D0/D1 are
swapped, you'll instead see <code>'R'</code>, <code>'Q'</code>, <code>'Z'</code>.</p>
<p>Here is some example code:</p>
<pre><code class="language-c">// reset the chip
_FLASH_WRITE(0, 0xF0);
// enter CFI mode
_FLASH_WRITE(0xAA, 0x98);

// read the header
u16 Q = *(((u16 *)AGB_ROM)+(0x20/2));
u16 R = *(((u16 *)AGB_ROM)+(0x22/2));
u16 Y = *(((u16 *)AGB_ROM)+(0x24/2));
bool swapBits = false;

if (Q == 'Q' &amp;&amp; R == 'R' &amp;&amp; Y == 'Y') {
  // CFI mode is enabled, D0/D1 are not swapped
  swapBits = false;
}
else if (Q == 'R' &amp;&amp; R == 'Q' &amp;&amp; Y == 'Z') {
  // CFI mode is enabled, D0/D1 are swapped
  swapBits = true;
}
else {
  // chip didn't enter CFI mode, try something else
}
</code></pre>
<p>Once you know if D0/D1 are swapped, you can write a helper function for reading bytes from the ROM:</p>
<pre><code class="language-c">u8 readByte(int addr, bool swapBits) {
  u8 data = *(((u16 *)AGB_ROM)+(addr/2));
  if (swapBits) {
    data =
      (data &amp; 0xfc) |
      ((data &amp; 1) &lt;&lt; 1) |
      ((data &amp; 2) &gt;&gt; 1);
  }
  return data;
}
</code></pre>
<h2 id="understanding-region-layout"><a class="header" href="#understanding-region-layout">Understanding Region Layout</a></h2>
<p>The region layout is useful for calculating where the sectors start, and how large they are.
Assuming you want to overwrite sectors at the end of the ROM, you need to figure out what
address(es) to write to.</p>
<p>There are 1-4 regions, and each region has a sector count and sector size.</p>
<p>After entering CFI mode, you can read the region layout from memory:</p>
<p><img src="bootleg-carts/images/regions.png" alt="Region Layout Memory Locations" /></p>
<p>Here's some example code:</p>
<pre><code class="language-c">// assuming we are already in CFI mode
int regionCount = readByte(0x58, swapBits);
struct {
  int sectorCount;
  int sectorSize;
} regions[4] = {0};

for (int region = 0; region &lt; regionCount; region++) {
  int sectorCountLow  = readByte(0x5A + region * 8, swapBits);
  int sectorCountHigh = readByte(0x5C + region * 8, swapBits);
  int sectorSizeLow   = readByte(0x5E + region * 8, swapBits);
  int sectorSizeHigh  = readByte(0x60 + region * 8, swapBits);

  // note we must add one!
  regions[region].sectorCount =
    ((sectorCountHigh &lt;&lt; 8) | sectorCountLow) + 1;

  // note we must multiply by 256!
  regions[region].sectorSize =
    ((sectorSizeHigh &lt;&lt; 8) | sectorSizeLow) &lt;&lt; 8;
}
</code></pre>
<h2 id="erasing-a-sector"><a class="header" href="#erasing-a-sector">Erasing a Sector</a></h2>
<p>Erasing a sector will set all the values in that sector to <code>0xFFFF</code>.</p>
<p>This is fairly straight forward, you can use
<a href="https://github.com/lesserkuma/goombacolor/blob/f2bae8eb5087de14008250032c82cf5d294131cd/src/main.c#L657">goombacolor</a>
as a reference:</p>
<pre><code class="language-c">// Erase flash sector
_FLASH_WRITE(sa, 0xF0);
_FLASH_WRITE(0xAAA, 0xA9);
_FLASH_WRITE(0x555, 0x56);
_FLASH_WRITE(0xAAA, 0x80);
_FLASH_WRITE(0xAAA, 0xA9);
_FLASH_WRITE(0x555, 0x56);
_FLASH_WRITE(sa, 0x30);
while (1) {
  __asm(&quot;nop&quot;);
  if (*(((u16 *)AGB_ROM)+(sa/2)) == 0xFFFF) {
    break;
  }
}
_FLASH_WRITE(sa, 0xF0);
</code></pre>
<p>You now should be able to understand this code.</p>
<p>This sequence of writes matches the documentation (with D0/D1 swapped).</p>
<p>The variable <code>sa</code> is the sector address.  The code:</p>
<ol>
<li>Resets the chip</li>
<li>Erases the sector</li>
<li>Waits in a loop until it reads <code>0xFFFF</code> from the sector, indicating the erase is finished</li>
<li>Resets the chip again</li>
</ol>
<h2 id="saving-data"><a class="header" href="#saving-data">Saving Data</a></h2>
<p>Once again, <a href="https://github.com/lesserkuma/goombacolor/blob/f2bae8eb5087de14008250032c82cf5d294131cd/src/main.c#L673">goombacolor</a>
is a great reference:</p>
<pre><code class="language-c">for (int i=0; i&lt;AGB_SRAM_SIZE; i+=2) {
  _FLASH_WRITE(0xAAA, 0xA9);
  _FLASH_WRITE(0x555, 0x56);
  _FLASH_WRITE(0xAAA, 0xA0);
  _FLASH_WRITE(sa+i, (*(u8 *)(AGB_SRAM+i+1)) &lt;&lt; 8 | (*(u8 *)(AGB_SRAM+i)));
  while (1) {
    __asm(&quot;nop&quot;);
    if (*(((u16 *)AGB_ROM)+((sa+i)/2)) == ((*(u8 *)(AGB_SRAM+i+1)) &lt;&lt; 8 | (*(u8 *)(AGB_SRAM+i)))) {
      break;
    }
  }
}
_FLASH_WRITE(sa, 0xF0);
</code></pre>
<p>The code:</p>
<ol>
<li>Issues a &quot;Program&quot; command for each 16-bit value</li>
<li>Writes the 16-bit value at the target address</li>
<li>Waits in a loop until it reads the written value*</li>
<li>Continues writing until all 16-bit values are written</li>
<li>Resets the chip</li>
</ol>
<p>Note that this code copies data from SRAM into the ROM.  As a homebrew developer, you don't <em>have</em>
to do it this way -- you can just write directly to the ROM.  However, you should still have code
that saves to SRAM so that emulators can save the data.</p>
<p>* You might think this loop could be incorrect if by chance, the read returns the value written
before it was actually finished.  See the section on DQ7 Data Polling on page 59 to understand why
this won't happen.  In summary, DQ7 will always be the opposite of whatever was written until the
write goes through.</p>
<h2 id="final-thoughts"><a class="header" href="#final-thoughts">Final Thoughts</a></h2>
<p>This guide is a starting point, but it cannot replace experimentation.  Now that you understand the
basic idea, here are some things you will want to consider:</p>
<ol>
<li>If a user shuts off power during a save, then the save will be incomplete.  You can backup the
save into another sector to ensure the data will always be recoverable.</li>
<li>If you want your game to work on emulators, you will still need to save to SRAM.  However, if you
don't care about emulators, then you can have much larger save files (for example, reserving 8 MB
for game code, 4 MB for save data, and 4 MB for backup).</li>
<li>Different chips have different commands, so if you want to support multiple chips, you will need
a method to detect which chip you're on, and use the appropriate commands.
<a href="https://github.com/lesserkuma/FlashGBX/blob/master/FlashGBX/hw_GBxCartRW.py#L1469">FlashGBX</a> and
<a href="https://github.com/lesserkuma/goombacolor/blob/main/src/main.c#L554">goombacolor</a>
are great references for this, and they both use different methods.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h1>
<p>The following are individuals who contributed info or corrections on the original CowBiteSpec document.</p>
<ul>
<li>Tom Happ</li>
<li>Agent Q (Wrote the original spec, version 1.0)</li>
<li>Uze (All of the sound register info comes directly from his Audio Advance site)</li>
<li>Martin Korth (Author no$gba of who has given me permission to consolidate additional info from his emulator's informative help documents with this one, most particularly serial registers, some BIOS functions, and undocumented registers.)</li>
<li>Forgotten (VBA Author. Many of the BIOS call descriptions come from his Visual Boy Advance FAQ.</li>
<li>gbcft (LOTS of info on interrupts, windowing, memory mirrors, the &quot;Unkown Registers&quot; section; helped me debug a lot of errors in the emulator, and offered many corrections, info, and suggestions).</li>
<li>Kay (Contributed memory port sizes and wait states, DMA cycle timings, info regarding the BIOS, and various advice, testing, and expertise regarding the GBA and older console systems)</li>
<li>Damian Yerrick (Contributed the WSCOUNT register)</li>
<li>Markus (Actually I asked him for help with LZSS. Also, his gfx2gba tool has proven extremely helpful in my non-CowBite projects.:)</li>
<li>ePac (Gave me links to serial info and did a nice writeup about it in the gbadev group)</li>
<li>Costis (A variety of new info/corrections)</li>
<li>Grauw (Info on forced blanking, hblank lenghths, and on the BIOS wait function.)</li>
<li>Max</li>
<li>Otaku</li>
<li>Ped (Pointed out errors in the memory ranges, DISPCNT bit 5, and a bad typo regarding rotates/scale backgrounds).</li>
<li>Yarpen (Almost all the information on the timer registers and the keyboard control register. Thanks!)</li>
<li>http://www.gbadev.org/</li>
<li>The gbadev list on yahoo</li>
<li>SimonB and all the others who run/moderate the above sites</li>
<li>Dovoto and the PERN Project</li>
<li>Jeff Frohwein and his Devrs.com site</li>
<li>Nocturn and his tutorials</li>
<li>Uze from BeLogic for all the great information on the GBA's sound!</li>
<li>Andrew May for his site on GBA serial data</li>
</ul>
<p>Thank you to Alec Bourque for allowing us to use all assets of The Audio Advance in this documentation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
